        -:    0:Source:dijkstra.c
        -:    0:Graph:dijkstra.gcno
        -:    0:Data:dijkstra.gcda
        -:    0:Runs:1
        -:    1:// C Program to Implement Shortest Path Algorithm
        -:    2:// From GeeksForGeeks: https://www.geeksforgeeks.org/shortest-path-algorithm-in-c/#implementation-of-dijkstras-algorithm-in-c
        -:    3:#include <limits.h>
        -:    4:#include <stdio.h>
        -:    5:#include <stdbool.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:// Function to find the vertex with the minimum distance
        -:    9:// value from the set of vertices not yet included in the
        -:   10:// shortest path tree
        3:   11:int findminDistance(int dist[], int included[], int V) {
        3:   12:    int min = INT_MAX, min_index;
        -:   13:
        -:   14:    // Traverse all vertices to find the vertex with the
        -:   15:    // minimum distance value
       15:   16:    for (int v = 0; v < V; v++) {
       12:   17:        if (included[v] == 0 && dist[v] <= min) {
        7:   18:            min = dist[v];
        7:   19:            min_index = v;
        -:   20:        }
        -:   21:    }
        3:   22:    return min_index;
        -:   23:}
        -:   24:
        -:   25:// Function to print the constructed distance array
        1:   26:void printSolution(int dist[], int V) {
        1:   27:    printf("Vertex \t Distance from Source\n");
        5:   28:    for (int i = 0; i < V; i++) {
        4:   29:        if (dist[i] == INT_MAX) {
        1:   30:            printf("%d \t\t INF\n", i);
        1:   31:            continue;
        -:   32:        }
        3:   33:        else printf("%d \t\t %d\n", i, dist[i]);
        -:   34:    }
        1:   35:}
        -:   36:
        -:   37:// Function that implements Dijkstra's algorithm
        1:   38:void DijkstrasAlgo(int **graph, int src, int V) {
        -:   39:    // Array to store the minimum distance from source node
        -:   40:    // to the current node
        1:   41:    int dist[V];
        -:   42:    // Array to keep track of included nodes
        1:   43:    int included[V];
        -:   44:
        -:   45:    // Initialize all distances as INFINITE and included as
        -:   46:    // false
        5:   47:    for (int i = 0; i < V; i++) {
        4:   48:        dist[i] = INT_MAX;
        4:   49:        included[i] = 0;
        -:   50:    }
        -:   51:
        -:   52:    // Distance of source vertex from itself is always 0
        1:   53:    dist[src] = 0;
        -:   54:
        -:   55:    // Find the shortest path for all vertices
        4:   56:    for (int count = 0; count < V - 1; count++) {
        -:   57:        // Pick the minimum distance vertex from the set of
        -:   58:        // vertices not yet processed
        3:   59:        int u = findminDistance(dist, included, V);
        -:   60:
        -:   61:        // Mark the selected vertex as included
        3:   62:        included[u] = 1;
        -:   63:
        -:   64:        // Update the distance of all the adjacent vertices
        -:   65:        // of the selected vertex
       15:   66:        for (int v = 0; v < V; v++) {
        -:   67:            // update dist[v] if it is not already included,
        -:   68:            // and the current distance is less than its
        -:   69:            // original distance
       12:   70:            if (!included[v] && graph[u][v]
        3:   71:                && dist[u] != INT_MAX
        3:   72:                && dist[u] + graph[u][v] < dist[v]) {
        2:   73:                dist[v] = dist[u] + graph[u][v];
        -:   74:            }
        -:   75:        }
        -:   76:    }
        -:   77:
        -:   78:    // Print the constructed distance array
        1:   79:    printSolution(dist, V);
        1:   80:}
        -:   81:
        1:   82:int main() {
        -:   83:    int V, E;
        -:   84:
    #####:   85:    for (;;) { // Infinite loop for accepting new graphs dynamically
        1:   86:        printf("Enter the number of vertices: ");
        1:   87:        scanf("%d", &V);
        -:   88:
        1:   89:        if (V <= 0) {
    #####:   90:            printf("Invalid number of vertices.\n");
    #####:   91:            break;
        -:   92:        }
        -:   93:
        -:   94:        // Dynamically allocate memory for the graph
        1:   95:        int **graph = (int **)malloc(V * sizeof(int *));
        5:   96:        for (int i = 0; i < V; i++) {
        4:   97:            graph[i] = (int *)malloc(V * sizeof(int));
        -:   98:        }
        -:   99:
        -:  100:        // Reset the graph to zero
        5:  101:        for (int i = 0; i < V; i++) {
       20:  102:            for (int j = 0; j < V; j++) {
       16:  103:                graph[i][j] = 0;
        -:  104:            }
        -:  105:        }
        -:  106:
        1:  107:        printf("Enter the number of edges: ");
        1:  108:        scanf("%d", &E);
        -:  109:
        -:  110:        // Clear the input buffer
        1:  111:        while (getchar() != '\n');
        -:  112:
        1:  113:        if (E < 0 || E > V * (V - 1) / 2) { // Validate number of edges
    #####:  114:            printf("Invalid number of edges.\n");
    #####:  115:            for (int i = 0; i < V; i++) free(graph[i]);
    #####:  116:            free(graph);
    #####:  117:            break;
        -:  118:        }
        -:  119:
        1:  120:        if(E != 0) printf("Enter the edges in the format: src dest weight\n");
        8:  121:        for (int i = 0; i < E; i++) {
        -:  122:            int src, dest, weight;
        -:  123:
        -:  124:            // Read the edge input in format of (src dest weight)
       7*:  125:            if (scanf("%d %d %d", &src, &dest, &weight) != 3) {
    #####:  126:                printf("Invalid input format. Enter exactly three integers separated by spaces (src dest weight).\n");
    #####:  127:                while (getchar() != '\n'); // Clear the buffer
    #####:  128:                i--; // Request input for this edge again
       4*:  129:                continue;
        -:  130:            }
        -:  131:
        7:  132:            if (src < 0 || src >= V || dest < 0 || dest >= V || src == dest || weight < 0) {
        4:  133:                printf("Invalid edge (self-loop, out of range or negative weight), try again.\n");
        4:  134:                i--; // Request input for this edge again
        4:  135:                continue;
        -:  136:            }
        -:  137:
        3:  138:            graph[src][dest] = weight;
        3:  139:            graph[dest][src] = weight; // If the graph is undirected
        -:  140:        }
        -:  141:
        -:  142:        int src;
        1:  143:        printf("Enter the source vertex: ");
        1:  144:        scanf("%d", &src);
        -:  145:
        1:  146:        if (src < 0 || src >= V) {
    #####:  147:            printf("Invalid source vertex.\n");
    #####:  148:            for (int i = 0; i < V; i++) free(graph[i]);
    #####:  149:            free(graph);
    #####:  150:            break;
        -:  151:        }
        -:  152:
        1:  153:        DijkstrasAlgo(graph, src, V);
        -:  154:
        -:  155:        // Free dynamically allocated memory
        5:  156:        for (int i = 0; i < V; i++) free(graph[i]);
        1:  157:        free(graph);
        -:  158:
        -:  159:        char choice;
        1:  160:        printf("\nYou are about to create a new graph. Enter '0' if you want to stop the running of the script or enter something else to continue:\n");
        1:  161:        scanf(" %c", &choice);
        1:  162:        if (choice == '0') {
        1:  163:            break;
        -:  164:        }
        -:  165:    }
        -:  166:
        1:  167:    return 0;
        -:  168:}
